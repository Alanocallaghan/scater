#' Sum counts across sets of cells
#' 
#' Sum together expression values (by default, counts) for each set of cells and for each feature.
#'
#' @param x For \code{sumCountsAcrossCells}, a numeric matrix of counts containing features in rows and cells in columns.
#' Alternatively, a \linkS4class{SummarizedExperiment} object containing such a count matrix.
#'
#' For \code{aggregateAcrossCells}, a \linkS4class{SingleCellExperiment} or SummarizedExperiment containing a count matrix.
#' @param ids A factor specifying the set to which each cell in \code{x} belongs.
#'
#' Alternatively, a \linkS4class{DataFrame} of such vectors or factors, in which case each unique combination of levels defines a set. 
#' @param subset_row An integer, logical or character vector specifying the features to use.
#' Defaults to all features.
#' 
#' For the \linkS4class{SingleCellExperiment} method, this argument will not affect alternative Experiments,
#' where summation is always performed for all features (or not at all, depending on \code{use_alt_exps}).
#' @param subset_col An integer, logical or character vector specifying the cells to use.
#' Defaults to all cells with non-\code{NA} entries of \code{ids}.
#' @param exprs_values A string or integer scalar specifying the assay of \code{x} containing the matrix of counts
#' (or any other expression quantity that can be meaningfully summed).
#' @param average Logical scalar indicating whether the average should be computed instead of the sum.
#' @param BPPARAM A \linkS4class{BiocParallelParam} object specifying whether summation should be parallelized.
#' @param ... For the generics, further arguments to be passed to specific methods.
#' 
#' For the \code{sumCountsAcrossCells} SummarizedExperiment method, further arguments to be passed to the ANY method.
#'
#' For \code{aggregateAcrossCells}, further arguments to be passed to \code{sumCountsAcrossCells}.
#' @param use_exprs_values A character or integer vector specifying the assay(s) of \code{x} containing count matrices.
#' @param use_altexps Logical scalar indicating whether aggregation should be performed for alternative experiments in \code{x}.
#'
#' Alternatively, a character vector specifying the names of the alternative experiments to be aggregated.
#' @param coldata_merge A named list of functions specifying how each column metadata field should be aggregated.
#' For any unspecified field, metadata is retained for the first instance of a cell from each set in \code{ids}.
#' If \code{NULL}, the first instance is retained for all fields.
#'
#' @return 
#' For \code{sumCountsAcrossCells} with a factor \code{ids}, a count matrix is returned with one column per level of \code{ids}.
#' For each feature, counts for all cells in the same set are summed together.
#' Columns are ordered by \code{levels(ids)}.
#'
#' For \code{sumCountsAcrossCells} with a DataFrame \code{ids}, a SummarizedExperiment is returned containing a similar count matrix in the first assay.
#' Each column corresponds to a unique combination of levels in \code{ids} and contains the sum of counts for all cells with that combination.
#' The identities of the levels for each column are reported in the \code{\link{colData}}.
#'
#' For \code{aggregateAcrossCells}, a SummarizedExperiment of the same class as \code{x} is returned,
#' containing summed matrices generated by \code{sumCountsAcrossCell} on all assays specified by \code{use_exprs_values}.
#' By default, column metadata is retained for the first instance of a cell from each set in \code{ids},
#' but this behavior can be customized by supplying appropriate functions to \code{coldata_merge}.
#' If \code{ids} is a DataFrame, the combination of levels corresponding to each column is also reported in the column metadata.
#'
#' @details
#' This function provides a convenient method for aggregating counts across multiple columns for each feature.
#' A typical application would be to sum counts across all cells in each cluster to obtain \dQuote{pseudo-bulk} samples for further analysis.
#'
#' The behaviour of this function is equivalent to that of \code{\link{colsum}}.
#' However, this function can operate on any matrix representation in \code{object};
#' can do so in a parallelized manner for large matrices without resorting to block processing;
#' and can natively support combinations of multiple factors in \code{ids}.
#'
#' Any \code{NA} values in \code{ids} are implicitly ignored and will not be considered during summation.
#' This may be useful, e.g., to remove undesirable cells by setting their entries in \code{ids} to \code{NA}.
#' Alternatively, we can explicitly select the cells of interest with \code{subset_col}.
#' 
#' Setting \code{average=TRUE} will compute the average in each set rather than the sum.
#' This is particularly useful if \code{x} contains expression values that have already been normalized in some manner,
#' as computing the average avoids another round of normalization to account for differences in the size of each set.
#'
#' @author Aaron Lun
#' @name sumCountsAcrossCells
#'
#' @examples
#' example_sce <- mockSCE()
#' ids <- sample(LETTERS[1:5], ncol(example_sce), replace=TRUE)
#'
#' out <- sumCountsAcrossCells(example_sce, ids)
#' head(out)
#'
#' batches <- sample(1:3, ncol(example_sce), replace=TRUE)
#' out2 <- sumCountsAcrossCells(example_sce, 
#'       DataFrame(label=ids, batch=batches))
#' out2
#'
#' # Using another column metadata merge strategy.
#' example_sce$stuff <- runif(ncol(example_sce))
#' example_merged <- aggregateAcrossCells(example_sce, ids, 
#'      coldata_merge=list(stuff=sum))
NULL

#' @importFrom BiocParallel SerialParam bplapply 
#' @importClassesFrom S4Vectors DataFrame
#' @importFrom methods is
#' @importFrom SummarizedExperiment SummarizedExperiment
#' @importFrom Matrix t 
.sum_counts_across_cells <- function(x, ids, subset_row=NULL, subset_col=NULL, average=FALSE, BPPARAM=SerialParam()) {
    multi <- is(ids, "DataFrame")
    if (multi) {
        coldata <- ids
        ids <- .df_to_factor(ids)
    } 
    if (ncol(x)!=length(ids)) {
        stop("length of 'ids' and 'ncol(x)' are not equal")
    }

    if (!is.null(subset_col)) {
        ids[!seq_along(ids) %in% .subset2index(subset_col, x, byrow=FALSE)] <- NA_integer_
    }
    lost <- is.na(ids)

    by.core <- .splitRowsByWorkers(x, BPPARAM=BPPARAM, 
        subset_row=.subsetToIndexOrNull(subset_row, x, byrow=TRUE),
        subset_col=if (any(lost)) which(!lost))

    sub.ids <- ids[!lost]
    out <- bplapply(by.core, FUN=.colsum, group=sub.ids, BPPARAM=BPPARAM)
    out <- do.call(rbind, out)

    if (average) {
        freq <- table(sub.ids)
        out <- t(t(out)/as.integer(freq[colnames(out)]))
    }

    if (multi) {
        m <- match(as.integer(colnames(out)), ids)
        out <- SummarizedExperiment(list(sum=out), colData=coldata[m,,drop=FALSE])
        colnames(out) <- NULL
    }

    out
}

#' @importFrom S4Vectors selfmatch
.df_to_factor <- function(ids) {
    x <- selfmatch(ids) 
    x[Reduce("|", lapply(ids, is.na))] <- NA_integer_
    x
}

#' @export
#' @rdname sumCountsAcrossCells
setMethod("sumCountsAcrossCells", "ANY", .sum_counts_across_cells)

#' @export
#' @rdname sumCountsAcrossCells
#' @importFrom SummarizedExperiment assay
setMethod("sumCountsAcrossCells", "SummarizedExperiment", function(x, ..., exprs_values="counts") {
    .sum_counts_across_cells(assay(x, exprs_values), ...)
})

##########################
##########################

setGeneric(".colsum", function(x, group) standardGeneric(".colsum"))

#' @importFrom Matrix rowSums
setMethod(".colsum", "ANY", function(x, group) {
    by.group <- split(seq_len(ncol(x)), group)
    out <- lapply(by.group, function(i) rowSums(x[,i,drop=FALSE]))
    do.call(cbind, out)
})

#' @importFrom DelayedArray colsum
setMethod(".colsum", "matrix", function(x, group) {
    colsum(x, group)
})

#' @importFrom DelayedArray colsum
setMethod(".colsum", "DelayedMatrix", function(x, group) {
    colsum(x, group)
})

##########################
##########################

#' @export
#' @rdname sumCountsAcrossCells
setMethod("aggregateAcrossCells", "SummarizedExperiment", function(x, ids, ..., 
    coldata_merge=NULL, use_exprs_values="counts") 
{
    FUN <- .create_cell_aggregator(ids, use_exprs_values, coldata_merge)
    FUN(x, ...)
})

#' @importClassesFrom S4Vectors DataFrame
#' @importFrom methods is
#' @importFrom SummarizedExperiment assays<- assayNames colData<- colData
.create_cell_aggregator <- function(ids, use_exprs_values, coldata_merge) {
    multi <- is(ids, "DataFrame")
    if (multi) {
        combos <- ids
        ids <- .df_to_factor(ids)
    } 

    force(use_exprs_values)
    force(coldata_merge)

    function(y, ..., subset_row=NULL) {
        if (!is.null(subset_row)) {
            y <- y[subset_row,]
        }

        collected <- list()
        for (i in seq_along(use_exprs_values)) {
            collected[[i]] <- sumCountsAcrossCells(y, ids=ids, ..., exprs_values=use_exprs_values[i])
        }
        names(collected) <- .choose_assay_names(x, use_exprs_values)

        cn <- colnames(collected[[1]])
        ids <- as.character(ids)
        new.cd <- .merge_DF_rows(colData(y), ids, cn, coldata_merge)

        m <- match(cn, ids) 
        y <- y[,m]
        assays(y) <- collected
        colData(y) <- new.cd # implicitly resets column names.

        if (multi) {
            colData(y) <- cbind(colData(y), combos[m,,drop=FALSE])
            colnames(y) <- NULL
        }

        y
    }
}

#' @importFrom BiocGenerics match
#' @importFrom S4Vectors split
.merge_DF_rows <- function(x, ids, final, coldata_merge=NULL) {
    final <- as.character(final)
    ids <- as.character(ids)

    collected <- x[match(final, ids),,drop=FALSE] 
    rownames(collected) <- final

    for (cn in colnames(x)) {
        if (is.list(coldata_merge)) {
            if (is.null(FUN <- coldata_merge[[cn]])) {
                next
            }
        } else if (is.null(coldata_merge)) {
            next
        } else {
            FUN <- coldata_merge
        }

        grouped <- split(x[[cn]], ids)[final]
        collected[[cn]] <- unlist(lapply(grouped, FUN))
    }

    collected
}

#' @export
#' @rdname sumCountsAcrossCells
#' @importFrom SingleCellExperiment altExp altExps altExp<- altExps<-
setMethod("aggregateAcrossCells", "SingleCellExperiment", function(x, ids, 
    ..., subset_row=NULL, coldata_merge=NULL,
    use_exprs_values="counts", use_altexps=TRUE)
{
    FUN <- .create_cell_aggregator(ids, use_exprs_values, coldata_merge)
    y <- FUN(x, ..., subset_row=subset_row)
    use_altexps <- .get_altexps_to_use(x, use_altexps)
    for (i in use_altexps) {
        altExp(y, i) <- FUN(altExp(x, i), ...)
    }
    altExps(y) <- altExps(y, withColData=FALSE)[use_altexps]
    y
})
