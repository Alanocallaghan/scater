#' Sum counts across a set of cells
#' 
#' Create a count matrix where counts for all cells in a set are summed together.
#'
#' @param x For \code{sumCountsAcrossCells}, a numeric matrix of counts containing features in rows and cells in columns.
#' Alternatively, a \linkS4class{SummarizedExperiment} object containing such a count matrix.
#'
#' For \code{aggregateAcrossCells}, a \linkS4class{SingleCellExperiment} or SummarizedExperiment containing a count matrix.
#' @param ids A factor specifying the set to which each cell in \code{x} belongs.
#' @param assay.type A string or integer scalar specifying the assay of \code{x} containing the matrix of counts
#' (or any other expression quantity that can be meaningfully summed).
#' @param exprs_values Deprecated, same as \code{assay.type}.
#' @param BPPARAM A \linkS4class{BiocParallelParam} object specifying whether summation should be parallelized.
#' @param ... For the generics, further arguments to be passed to specific methods.
#' 
#' For the \code{sumCountsAcrossCells} SummarizedExperiment method, further arguments to be passed to the ANY method.
#'
#' For \code{aggregateAcrossCells}, further arguments to be passed to \code{sumCountsAcrossCells}.
#' @param use.assay.types A character or integer vector specifying the assay(s) of \code{x} containing count matrices.
#'
#' @return 
#' For \code{sumCountsAcrossCells}, a count matrix is returned with one column per level of \code{ids}.
#' For each feature, counts for all cells in the same set are summed together.
#' Columns are ordered by \code{levels(ids)}.
#'
#' For \code{aggregateAcrossCells}, a SummarizedExperiment of the same class as \code{x} is returned,
#' containing summed matrices generated by \code{sumCountsAcrossCell} on all \code{use.assay.types}.
#' Column metadata is retained for the first instance of a cell from each set in \code{ids}.
#'
#' @details
#' This function provides a convenient method for aggregating counts across multiple columns for each feature.
#' A typical application would be to sum counts across all cells in each cluster to obtain \dQuote{pseudo-bulk} samples for further analysis.
#'
#' The behaviour of this function is equivalent to that of \code{\link{colsum}}.
#' However, this function can operate on any matrix representation in \code{object},
#' and can do so in a parallelized manner for large matrices without resorting to block processing.
#'
#' Any \code{NA} values in \code{ids} are implicitly ignored and will not be considered or reported.
#' This may be useful, e.g., to remove undesirable cells by setting their entries in \code{ids} to \code{NA}.
#'
#' @author Aaron Lun
#' @name sumCountsAcrossCells
#'
#' @examples
#' data("sc_example_counts")
#' data("sc_example_cell_info")
#' example_sce <- SingleCellExperiment(
#'     assays = list(counts = sc_example_counts), 
#'     colData = sc_example_cell_info)
#'
#' ids <- sample(LETTERS[1:5], ncol(example_sce), replace=TRUE)
#' out <- sumCountsAcrossCells(example_sce, ids)
#' dimnames(out)
NULL

#' @importFrom BiocParallel SerialParam bpmapply
.sum_counts_across_cells <- function(x, ids, BPPARAM=SerialParam()) {
    if (ncol(x)!=length(ids)) {
        stop("'length(ids)' and 'ncol(x)' are not equal")
    }

    by_set <- split(seq_along(ids) - 1L, ids)
    assignments <- .assign_jobs_to_workers(nrow(x), BPPARAM)
    out_list <- bpmapply(start=assignments$start, end=assignments$end, FUN=.sum_across_cols_internal, 
        MoreArgs=list(by_set=by_set, mat=x), BPPARAM=BPPARAM, SIMPLIFY=FALSE, USE.NAMES=FALSE)

    out <- do.call(rbind, out_list)
    dimnames(out) <- list(rownames(x), names(by_set))
    out
}

.sum_across_cols_internal <- function(mat, by_set, start, end) 
# Internal function to drag along the namespace.
{
    .Call(cxx_sum_col_counts, mat, by_set, start, end)
}

#' @export
#' @rdname sumCountsAcrossCells
setMethod("sumCountsAcrossCells", "ANY", .sum_counts_across_cells)

#' @export
#' @rdname sumCountsAcrossCells
#' @importFrom SummarizedExperiment assay
setMethod("sumCountsAcrossCells", "SummarizedExperiment", function(x, ..., assay.type="counts", exprs_values=NULL) {
    assay.type <- .switch_arg_names(exprs_values, assay.type)
    .sum_counts_across_cells(assay(x, assay.type), ...)    
})

#' @export
#' @rdname sumCountsAcrossCells
setMethod("aggregateAcrossCells", "SummarizedExperiment", function(x, ids, ..., use.assay.types="counts") {
    FUN <- .create_cell_aggregator(ids, use.assay.types)
    FUN(x, ...)
})

#' @importFrom SummarizedExperiment assays<- assayNames
.create_cell_aggregator <- function(ids, use.assay.types) {
    ids0 <- as.character(ids)
    force(use.assay.types)
    function(y, ...) {
        collected <- list()
        for (i in seq_along(use.assay.types)) {
            collected[[i]] <- sumCountsAcrossCells(y, ids=ids, ..., assay.type=use.assay.types[i])
        }
        names(collected) <- .choose_assay_names(x, use.assay.types)

        y <- y[,match(colnames(collected[[1]]), as.character(ids))]
        assays(y) <- collected
        colnames(y) <- colnames(collected[[1]])
        y
    }
}

#' @export
#' @rdname sumCountsAcrossCells
setMethod("aggregateAcrossCells", "SingleCellExperiment", function(x, ids, ..., use.assay.types="counts", use.alt.exps=TRUE) {
    FUN <- .create_cell_aggregator(ids, use.assay.types)
    x <- FUN(x, ...)
    use.alt.exps <- .get_alt_exps_to_use(x, use.alt.exps)
    for (i in use.alt.exps) {
        altExp(x, i) <- FUN(altExp(x, i), ...)
    }
    x
})
