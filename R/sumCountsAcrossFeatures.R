#' Sum counts across a feature set
#' 
#' Create a count matrix where counts for all features in a set are summed together.
#'
#' @param x For \code{sumCountsAcrossFeatures}, a numeric matrix of counts containing features in rows and cells in columns.
#' Alternatively, a \linkS4class{SummarizedExperiment} object containing such a count matrix.
#'
#' For \code{aggregateAcrossFeatures}, a SummarizedExperiment containing a count matrix.
#' @param ids A factor specifying the set to which each feature in \code{x} belongs.
#' @param exprs_values A string or integer scalar specifying the assay of \code{x} containing the matrix of counts
#' (or any other expression quantity that can be meaningfully summed).
#' @param BPPARAM A \linkS4class{BiocParallelParam} object specifying whether summation should be parallelized.
#' @param ... For the \code{sumCountsAcrossFeatures} generic, further arguments to be passed to specific methods.
#' 
#' For the SummarizedExperiment method, further arguments to be passed to the ANY method.
#'
#' For \code{aggregateAcrossFeatures}, further arguments to be passed to \code{sumCountsAcrossFeatures}.
#' @param use_exprs_values A character or integer vector specifying the assay(s) of \code{x} containing count matrices.
#'
#' @return 
#' For \code{sumCountsAcrossFeatures}, a count matrix is returned with one row per level of \code{ids}.
#' In each cell, counts for all features in the same set are summed together.
#' Rows are ordered according to \code{levels(ids)}.
#' 
#' For \code{aggregateAcrossFeatures}, a SummarizedExperiment of the same class as \code{x} is returned,
#' containing summed matrices generated by \code{sumCountsAcrossFeatures} on all assays in \code{use_exprs_values}.
#' Row metadata is retained for the first instance of a feature from each set in \code{ids}.
#'
#' @details
#' This function provides a convenient method for aggregating counts across multiple rows for each cell.
#' For example, genes with multiple mapping locations in the reference will often manifest as multiple rows with distinct Ensembl/Entrez IDs.
#' These counts can be aggregated into a single feature by setting the shared identifier (usually the gene symbol) as \code{ids}.
#'
#' It is theoretically possible to aggregate transcript-level counts to gene-level counts with this function.
#' However, it is often better to do so with dedicated functions (e.g., from the \pkg{tximport} or \pkg{tximeta} packages) that account for differences in length across isoforms.
#'
#' The behaviour of this function is equivalent to that of \code{\link{rowsum}}.
#' However, this function can operate on any matrix representation in \code{object},
#' and can do so in a parallelized manner for large matrices without resorting to block processing.
#'
#' Any \code{NA} values in \code{ids} are implicitly ignored and will not be considered or reported.
#' This may be useful, e.g., to remove undesirable feature sets by setting their entries in \code{ids} to \code{NA}.
#'
#' @author Aaron Lun
#' @name sumCountsAcrossFeatures
#'
#' @examples
#' data("sc_example_counts")
#' data("sc_example_cell_info")
#' example_sce <- SingleCellExperiment(
#'     assays = list(counts = sc_example_counts), 
#'     colData = sc_example_cell_info)
#'
#' ids <- sample(LETTERS, nrow(example_sce), replace=TRUE)
#' out <- sumCountsAcrossFeatures(example_sce, ids)
#' dimnames(out)
NULL

#' @importFrom BiocParallel SerialParam bpmapply
.sum_counts_across_features <- function(x, ids, BPPARAM=SerialParam()) {
    if (nrow(x)!=length(ids)) {
        stop("'length(ids)' and 'nrow(x)' are not equal")
    }

    ids <- as.factor(ids)
    ans <- integer(length(ids))
    ans <- as.integer(ids) - 1L

    assignments <- .assign_jobs_to_workers(ncol(x), BPPARAM)
    out_list <- bpmapply(start=assignments$start, end=assignments$end, 
        FUN=.sum_across_rows_internal, 
        MoreArgs=list(by_set=ans, ntotal=nlevels(ids), mat=x), 
        BPPARAM=BPPARAM, SIMPLIFY=FALSE, USE.NAMES=FALSE)

    out <- do.call(cbind, out_list)
    dimnames(out) <- list(levels(ids), colnames(x))
    out
}

.sum_across_rows_internal <- function(mat, by_set, ntotal, start, end) 
# Internal function to drag along the namespace.
{
    .Call(cxx_sum_row_counts, mat, by_set, ntotal, start, end)
}

#' @export
#' @rdname sumCountsAcrossFeatures
setMethod("sumCountsAcrossFeatures", "ANY", .sum_counts_across_features)

#' @export
#' @rdname sumCountsAcrossFeatures
#' @importFrom SummarizedExperiment assay
#' @importClassesFrom SummarizedExperiment SummarizedExperiment
setMethod("sumCountsAcrossFeatures", "SummarizedExperiment", function(x, ..., exprs_values="counts") {
    .sum_counts_across_features(assay(x, exprs_values), ...)    
})

#' @export
#' @rdname sumCountsAcrossFeatures
#' @importFrom SummarizedExperiment assays<- assayNames
aggregateAcrossFeatures <- function(x, ids, ..., use_exprs_values="counts") {
    collected <- list()
    for (i in seq_along(use_exprs_values)) {
        collected[[i]] <- sumCountsAcrossFeatures(x, ids=ids, ..., exprs_values=use_exprs_values[i])
    }
    names(collected) <- .choose_assay_names(x, use_exprs_values)

    x <- x[match(rownames(collected[[1]]), as.character(ids)),]
    assays(x) <- collected
    rownames(x) <- rownames(collected[[1]])
    x
}

#' @importFrom SummarizedExperiment assayNames
.choose_assay_names <- function(x, use_exprs_values) {
    if (is.numeric(use_exprs_values)) {
        assayNames(x)[use_exprs_values]
    } else {
        use_exprs_values
    }
}
