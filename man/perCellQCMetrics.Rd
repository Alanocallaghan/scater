% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllGenerics.R, R/perCellQCMetrics.R
\docType{methods}
\name{perCellQCMetrics}
\alias{perCellQCMetrics}
\alias{perCellQCMetrics,ANY-method}
\alias{perCellQCMetrics,SummarizedExperiment-method}
\alias{perCellQCMetrics,SingleCellExperiment-method}
\title{Per-cell quality control metrics}
\usage{
perCellQCMetrics(x, ...)

\S4method{perCellQCMetrics}{ANY}(x, subsets = NULL, percent_top = c(50,
  100, 200, 500), detection.limit = 0, BPPARAM = SerialParam(),
  flatten = TRUE)

\S4method{perCellQCMetrics}{SummarizedExperiment}(x, ...,
  exprs_values = "counts")

\S4method{perCellQCMetrics}{SingleCellExperiment}(x, subsets = NULL,
  percent_top = c(50, 100, 200, 500), ..., flatten = TRUE,
  exprs_values = "counts", use_altexps = TRUE)
}
\arguments{
\item{x}{A numeric matrix of counts with cells in columns and features in rows.

Alternatively, a \linkS4class{SummarizedExperiment} or \linkS4class{SingleCellExperiment} object containing such a matrix.}

\item{...}{For the generic, further arguments to pass to specific methods.

For the SummarizedExperiment and SingleCellExperiment methods, further arguments to pass to the ANY method.}

\item{subsets}{A named list containing one or more vectors 
(a character vector of feature names, a logical vector, or a numeric vector of indices),
used to identify interesting feature subsets such as ERCC spike-in transcripts or mitochondrial genes.}

\item{percent_top}{An integer vector. 
Each element is treated as a number of top genes to compute the percentage of library size occupied by the most highly expressed genes in each cell.}

\item{detection.limit}{A numeric scalar specifying the lower detection limit for expression.}

\item{BPPARAM}{A BiocParallelParam object specifying whether the QC calculations should be parallelized.}

\item{flatten}{Logical scalar indicating whether the nested \linkS4class{DataFrame}s in the output should be flattened.}

\item{exprs_values}{A string or integer scalar indicating which \code{assays} in the \code{x} contains the count matrix.}

\item{use_altexps}{Logical scalar indicating whether QC statistics should be computed for alternative Experiments in \code{x}.
If \code{TRUE}, statistics are computed for all alternative experiments. 

Alternatively, an integer or character vector specifying the alternative Experiments to use to compute QC statistics.

Alternatively \code{NULL}, in which case alternative experiments are not used.}
}
\value{
A \linkS4class{DataFrame} of QC statistics where each row corresponds to a column in \code{x}.
This contains the following fields:
\itemize{
\item \code{sum}: numeric, the sum of counts for each cell.
\item \code{detected}: numeric, the number of observations above \code{detection.limit}.
}

If \code{flatten=FALSE}, the DataFrame will contain the additional columns:
\itemize{
\item \code{percent_top}: numeric matrix, the percentage of counts assigned to the percent_topage of most highly expressed genes.
Each column of the matrix corresponds to an entry of the sorted \code{percent_top}, in increasing order.
\item \code{subsets}: A nested DataFrame containing statistics for each subset, see Details.
\item \code{altexps}: A nested DataFrame containing statistics for each alternative experiment, see Details.
This is only returned for the SingleCellExperiment method.
\item \code{total}: numeric, the total sum of counts for each cell across main and alternative Experiments.
This is only returned for the SingleCellExperiment method.
}

If \code{flatten=TRUE}, nested matrices and DataFrames are flattened to remove the hierarchical structure from the output DataFrame.
}
\description{
Compute per-cell quality control metrics for a count matrix or a \linkS4class{SingleCellExperiment}.
}
\details{
This function calculates useful QC metrics for identification and removal of potentially problematic cells.
Obvious per-cell metrics are the sum of counts (i.e., the library size) and the number of detected features.
The percentage of counts in the top features also provides a measure of library complexity.

If \code{subsets} is specified, these statistics are also computed for each subset of features.
This is useful for investigating gene sets of interest, e.g., mitochondrial genes, Y chromosome genes.
These statistics are stored as nested \linkS4class{DataFrame}s in the \code{subsets} field of the output.
For example, if the input \code{subsets} contained \code{"Mito"} and \code{"Sex"}, the output would look like:
\preformatted{  output 
  |-- sum
  |-- detected
  |-- percent_top
  +-- subsets
      |-- Mito
      |   |-- sum
      |   |-- detected
      |   +-- percent
      +-- Sex 
          |-- sum
          |-- detected
          +-- percent
}
Here, the \code{percent} field contains the percentage of each cell's count sum assigned to each subset. 

If \code{use_altexps} is \code{TRUE}, the same statistics are computed for each alternative experiment in \code{x}.
This can also be an integer or character vector specifying the alternative Experiments to use.
These statistics are also stored as nested \linkS4class{DataFrame}s, this time in the \code{altexps} field of the output.
For example, if \code{x} contained the alternative Experiments \code{"Spike"} and \code{"Ab"}, the output would look like:
\preformatted{  output 
  |-- sum
  |-- detected
  |-- percent_top
  +-- altexps 
  |   |-- Spike
  |   |   |-- sum
  |   |   |-- detected
  |   |   +-- percent.total
  |   +-- Ab
  |       |-- sum
  |       |-- detected
  |       +-- percent.total
  +-- total 
}
The \code{total} field contains the total sum of counts for each cell across the main and alternative Experiments.
The \code{percent} field contains the percentage of the total count in each alternative Experiment for each cell.

If \code{flatten=TRUE}, the nested DataFrames are flattened by concatenating the column names with underscores.
This means that, say, the \code{subsets$Mito$sum} nested field becomes the top-level \code{subsets_Mito_sum} field.
A flattened structure is more convenient for end-users performing interactive analyses,
but less convenient for programmatic access as artificial construction of strings is required.
}
\examples{
data("sc_example_counts")
data("sc_example_cell_info")
example_sce <- SingleCellExperiment(
    assays = list(counts = sc_example_counts), 
    colData = sc_example_cell_info
)

stats <- perCellQCMetrics(example_sce)
stats

# With subsets.
stats2 <- perCellQCMetrics(example_sce, subsets=list(Mito=1:10), 
    flatten=FALSE)
stats2$subsets

# With alternative Experiments.
pretend.spike <- ifelse(seq_len(nrow(example_sce)) < 10, "Spike", "Gene")
alt_sce <- splitSCEByAlt(example_sce, pretend.spike)
stats3 <- perCellQCMetrics(alt_sce, flatten=FALSE)
stats3$altexps


}
\seealso{
\code{\link{addQCPerCell}}, to add the QC metrics to the column metadata.
}
\author{
Aaron Lun
}
